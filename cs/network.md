# Network

## HTTP와 HTTPS의 차이점
<details>
  <summary>HTTP(HyperText Transfer Protocol)</summary>
  서로 다른 시스템들이 통신을 주고받게 하는 프로토콜이다. 서버에서 자신의 브라우저로 데이터를 전송해주는 용도로 많이 사용된다.

  하지만 `사용자로부터 브라우저로 전송되는 정보`가 암호화가 되지 않는다.
  </details>

  <details>
  <summary>HTTPS(HyperText Transfer Protocol Secure)</summary>
    SSL(보안 소켓 계층)는 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들어주고 민감한 정보를 주고받을 때 도난당하는 것을 막아준다.

`SSL 인증서`는 사용자가 사이트에 제공하는 정보를 `암호화`한다. 또한 `TLS(전송 계층 보안)` 프로토콜을 통해 보안을 유지한다. TLS은 `데이터 무결성을 제공`하고 데이터가 전송 중에 수정되거나 손상되는 것을 방지한다. 또한 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능이 있다.

`검색엔진 최적화(SEO)`에도 혜택을 볼 수 있다. 다만 모든 데이터를 암호화해서 통신하면 과부화로 속도가 느려질 수 있다. 
  </details>


> 차이점
>
> HTTP는 서버로부터 브라우저로 전송되는 정보가 암호화가 되지 않지만 HTTPS는 SSL 인증서로 패킷을 암호화하고 TLS 프로토콜로 데이터 무결성을 제공한다. 또한 검색엔진 최적화 기능에서 혜택이 있다.

## TCP와 UDP의 차이점

  <details>
  <summary>TCP</summary>
TCP(Transmission Control Protocol)는 OSI 7 layer와 TCP/IP 4 layer의 전송계층에서 사용되는 프로토콜이다. 인터넷상에서 데이터를 메세지 형태로 보내기 위해 IP가 데이터를 배달하면 TCP가 패킷을 추적하고 관리한다.

`연결형` 서비스로 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정하는 `가상 회선 방식`을 제공한다. 서버 소켓은 연결만 담당한다. `3-way handshaking` 과정으로 목적지와 수신지를 확실하게 하여 세션을 수립한다. 따라서 높은 신뢰성을 보장한다.

데이터 처리속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 `흐름 제어`와 네트워크 내의 패킷 수가 증가하지 않도록 방지하는`혼잡 제어`가 이루어져 이는 CPU를 사용하기 때문에 속도에 영향을 주기 때문에 UDP보다 `속도가 느리다`. 

연속성보다 `신뢰성있는 전송`이 필요할 때 사용하는 프로토콜로 파일 전송 등이 있다. 패킷에 대한 응답이 이루어져 성능이 낮고 패킷이 손실되면 재전송 요청을 하기 때문에 streaming 서비스에 불리하다. 
  </details>

  <details>
  <summary>UDP</summary>
  UDP(User Datagram Protocol)는 데이터그램이라는 독립적인 관계를 지니는 패킷 단위로 데이터를 처리하는 프로토콜이다. 메세지 단위이다.

논리적인 경로가 없고 패킷이 독립적인 관계를 가지는 데이터를 서로 다른 경로로 처리한다.

`비연결형` 서비스이고 `데이터그램 방식`을 제공한다. 정보를 주고 받을 때 신호 절차가 없고 패킷에 순서를 부여하여 재조립하거나 흐름 제어와 혼잡 제어도 하지 않아 `속도가 빠르고` 부하가 적지만 신뢰성 있는 데이터 전송을 보장하지 못한다. 헤더의 checkSum 필드를 통해 최소한의 오류만 검증한다. 

신뢰성보다 `연속성`이 중요한 실시간 서비스에 사용된다.

소켓 대신 IP 기반 데이터 전송이 이루어진다.
  </details>

> 차이점
>
> TCP는 연결성 서비스로 가상회선 방식을 제공하는 프로토콜이고 UDP는 비연결성 서비스로 데이터그램 방식을 제공하는 프로토콜이다. TCP는 흐름 제어와 혼잡 제어가 있어 속도가 느리고 3 way handshaking 과정도 있어 신뢰성이 높다. UDP는 흐름 제어와 혼잡 제어도 없고 연결 신호 절차도 없어 속도가 빠르고 신뢰성보다 연속성이 중요한 실시간 서비스에 사용된다.

## TCP 3, 4 way handshake에 대해서 설명

  <details>
  <summary>TCP 3 way handshake</summary>
TCP 3 way handshake는 TCP의 `접속 과정`이다. TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정으로, 양쪽 모두 데이터를 전송할 준비가 되었음을 보장하고 전달이 시작되기 전에 다른쪽이 준비되었다는 것을 알 수 있도록 하는 것이다. 

즉 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 `사전에 세션을 수립`하는 과정이다.

PAR을 사용하는 기기는 `ACK`를 받을 때까지 데이터 유닛을 재전송하것인데, 수신자가 데이터 유닛이 손상된 것을 확인하면 해당 세그먼트를 없앤다. 전달자는 `positive ack`가 오지 않은 데이터 유닛을 다시 보내는 것이다. 이 과정에서 `3개의 세그먼트`가 교환되는 것이 3 way handshake이다.

클라이언트는 서버와 연결하기 위해 3 way handshake를 통해 연결을 요청한다. 클라이언트에서 `SYN(Synchronization)을 보내 서버에 연결 요청`을 한다. 세션을 설정하는데 사용되며 최초로 데이터를 전송할 때 임의의 랜덤한 `시퀀스 번호`를 함께 보낸다. 이때 클라이언트의 포트는 CLOSED에서 SYN_SENT로 변화하고 서버는 LISTEN 상태이다. 서버는 클라이언트로부터 SYN을 전송 받았다는 `ACK(Acknowledgement)`와 `SYN`의 시퀀스 번호에 TCP 계층에서의 길이 또는 양을 더한 것과 같은 값을 ACK에 포함하여 전송한다. 클라이언트의 포트는 CLOSED이고, 서버는 SYN_RCV 상태이다. 동기화에 대한 답변으로 클라이언트에서 시퀀스 번호에 1을 더하여 `ACK`를 돌려준다. 이때 전송할 데이터가 있다면 데이터를 전송할 수도 있다. 클라이언트의 포트는 `ESTABLISED(포트 연결 완료)` 상태이고 서버는 SYN_RCV에서 ESTABLISED로 변경된다. TCP는 3 way handshake로 데이터 송신과 수신이 가능하기 때문에 `full-duplex` 통신이 구축된다.

1. Client(CLOSED->SYN_SENT) -- SYN --> Server(LISTEN)
2. Client(SYN_SENT->CLOSED) <-- ACK, SYN -- Server(LISTEN->SYN_RCV)
3. Client(CLOSED->ESTABLISED) -- ACK --> Server(SYN_RCV->ESTABLISED)

> 설명
>
> TCP 3 way handshake는 TCP의 접속 과정이고 TCP 4 way handshake는 TCP의 접속 해제 과정이다. 3 way handshake는 사전에 세션을 연결하기 위해 3개의 세그먼트가 교환되는 것이 특징이고 클라이언트가 SYN를 서버에 보내 연결을 요청하고 서버는 ACK와 SYN의 시퀀스 번호에 TCP 계층의 길이를 포함해 클라이언트로 되돌려준다. 수신을 받은 클라이언트가 ACK를 서버에 되돌려주게 되면 포트가 ESTABLISED 상태가 되며 클라이언트와 서버 간의 full duplex 통신이 구축된다.

